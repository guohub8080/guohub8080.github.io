export const title = "Cloudflare Workers 入门指南";

# {title}

Cloudflare Workers 是一个在 Cloudflare 全球边缘网络上运行的无服务器（Serverless）平台。它允许你在靠近用户的位置运行 JavaScript/TypeScript 代码，无需管理服务器基础设施。

## 什么是 Cloudflare Workers？

Cloudflare Workers 基于 V8 JavaScript 引擎（Chrome 浏览器使用的同一引擎），运行在 Cloudflare 遍布全球的 300+ 个数据中心。

### 核心特点

- 极快的响应速度：代码在离用户最近的数据中心执行
- 全球分布：自动在全球范围内部署
- 按需付费：根据实际使用量计费
- 零冷启动：不同于传统 Serverless，几乎没有启动延迟
- 安全隔离：每个请求在独立的沙箱环境中运行

### 与传统服务器的区别

| 特性 | 传统服务器 | Cloudflare Workers |
|------|-----------|-------------------|
| 部署位置 | 固定数据中心 | 全球 300+ 数据中心 |
| 启动时间 | 需要服务器启动 | 0ms 冷启动 |
| 扩展性 | 手动配置 | 自动扩展 |
| 运维成本 | 需要维护 | 无需维护 |
| 计费方式 | 按时间/容量 | 按请求量 |

## Workers vs Web Workers

重要提示：不要混淆 Cloudflare Workers 和浏览器的 Web Workers。

### Web Workers（浏览器）

```javascript
// 浏览器中的 Web Worker - 运行在客户端
// main.js
const worker = new Worker('worker.js');
worker.postMessage({ type: 'calculate', value: 100 });

// worker.js
self.addEventListener('message', (e) => {
  const result = e.data.value * 2;
  self.postMessage(result);
});
```

特点：
- 运行在用户的浏览器中
- 用于多线程处理，不阻塞 UI
- 只能访问有限的浏览器 API
- 无法进行网络请求管理

### Cloudflare Workers（边缘计算）

```javascript
// Cloudflare Worker - 运行在服务器端
export default {
  async fetch(request, env, ctx) {
    return new Response('Hello from Cloudflare!');
  }
};
```

特点：
- 运行在 Cloudflare 的边缘服务器上
- 用于处理 HTTP 请求、API 路由、中间件等
- 可以访问网络、KV 存储、数据库等
- 作为服务器端代码运行

## JavaScript Worker 基础

### 最简单的 Worker

```javascript
// JavaScript Worker - 直接导出对象
export default {
  async fetch(request, env, ctx) {
    return new Response('Hello World!', {
      headers: { 'Content-Type': 'text/plain' }
    });
  }
};
```

### 处理不同的 HTTP 方法

```javascript
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    
    // 根据请求方法处理
    switch (request.method) {
      case 'GET':
        return new Response('GET 请求', { status: 200 });
        
      case 'POST':
        const body = await request.json();
        return new Response(JSON.stringify({
          message: '收到 POST 请求',
          data: body
        }), {
          headers: { 'Content-Type': 'application/json' }
        });
        
      case 'OPTIONS':
        return new Response(null, {
          headers: {
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type'
          }
        });
        
      default:
        return new Response('不支持的方法', { status: 405 });
    }
  }
};
```

### 路由处理

```javascript
export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;
    
    // 简单的路由
    if (path === '/') {
      return new Response('首页');
    }
    
    if (path === '/api/users') {
      return new Response(JSON.stringify([
        { id: 1, name: '张三' },
        { id: 2, name: '李四' }
      ]), {
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    if (path.startsWith('/api/user/')) {
      const userId = path.split('/').pop();
      return new Response(`用户 ID: ${userId}`);
    }
    
    return new Response('404 Not Found', { status: 404 });
  }
};
```

## TypeScript Worker

TypeScript Workers 提供类型安全和更好的开发体验。

### 基础 TypeScript Worker

```typescript
// TypeScript Worker - 使用类型定义
interface Env {
  // 环境变量类型
  API_KEY: string;
  MY_KV: KVNamespace;
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    return new Response('Hello TypeScript!');
  }
} satisfies ExportedHandler<Env>;
```

### 完整的 TypeScript 示例

```typescript
// 定义请求体类型
interface UserRequest {
  name: string;
  email: string;
  age?: number;
}

// 定义响应类型
interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  timestamp: string;
}

// 环境变量类型
interface Env {
  DATABASE_URL: string;
  API_SECRET: string;
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    const url = new URL(request.url);
    
    try {
      // GET 请求
      if (request.method === 'GET' && url.pathname === '/api/status') {
        const response: ApiResponse = {
          success: true,
          data: {
            status: 'running',
            version: '1.0.0',
            timestamp: new Date().toISOString()
          },
          timestamp: new Date().toISOString()
        };
        
        return Response.json(response);
      }
      
      // POST 请求
      if (request.method === 'POST' && url.pathname === '/api/user') {
        // 类型安全的请求体解析
        const body = await request.json() as UserRequest;
        
        // 验证必填字段
        if (!body.name || !body.email) {
          const errorResponse: ApiResponse = {
            success: false,
            error: '缺少必填字段',
            timestamp: new Date().toISOString()
          };
          return Response.json(errorResponse, { status: 400 });
        }
        
        // 成功响应
        const successResponse: ApiResponse<UserRequest> = {
          success: true,
          data: body,
          timestamp: new Date().toISOString()
        };
        
        return Response.json(successResponse, { status: 201 });
      }
      
      // 404
      return new Response('Not Found', { status: 404 });
      
    } catch (error) {
      const errorResponse: ApiResponse = {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      };
      
      return Response.json(errorResponse, { status: 500 });
    }
  }
} satisfies ExportedHandler<Env>;
```

### TypeScript 配置（wrangler.toml）

```toml
name = "my-worker"
main = "src/index.ts"
compatibility_date = "2024-01-01"

[build]
command = "npm run build"

# 环境变量
[vars]
ENVIRONMENT = "production"

# KV 命名空间
[[kv_namespaces]]
binding = "MY_KV"
id = "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
```

### TypeScript 的优势

```typescript
// 类型安全 - 编译时就能发现错误
interface User {
  id: number;
  name: string;
  email: string;
}

async function getUser(id: number): Promise<User> {
  // TypeScript 会检查返回值是否符合 User 类型
  return {
    id: id,
    name: 'John',
    email: 'john@example.com'
    // 如果缺少字段或类型错误，编译器会报错
  };
}

// 智能提示
const user = await getUser(1);
console.log(user.name); // IDE 会提示 name 属性

// 类型错误会在编译时被捕获
// console.log(user.age); // TypeScript 会报错：User 没有 age 属性
```

## JavaScript vs TypeScript Workers 对比

### JavaScript Worker

优点：
- 简单直接，无需编译
- 快速原型开发
- 学习曲线平缓
- 文件更小

缺点：
- 缺少类型检查
- 运行时才能发现错误
- IDE 智能提示有限
- 重构困难

### TypeScript Worker

优点：
- 类型安全
- 编译时错误检查
- 强大的 IDE 支持
- 更好的代码维护性
- 自动补全和文档

缺点：
- 需要编译步骤
- 配置稍复杂
- 学习成本略高

## 实战：CORS 代理

一个完整的 TypeScript Worker 示例 - 创建 CORS 代理：

```typescript
interface Env {
  ALLOWED_ORIGINS: string; // 允许的源，逗号分隔
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    const url = new URL(request.url);
    const origin = request.headers.get('Origin') || '';
    
    // 检查是否允许该源
    const allowedOrigins = env.ALLOWED_ORIGINS?.split(',') || ['*'];
    const isAllowed = allowedOrigins.includes('*') || 
                      allowedOrigins.includes(origin);
    
    // 处理 OPTIONS 预检请求
    if (request.method === 'OPTIONS') {
      return new Response(null, {
        headers: {
          'Access-Control-Allow-Origin': isAllowed ? origin || '*' : 'null',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          'Access-Control-Max-Age': '86400',
        }
      });
    }
    
    try {
      // 获取目标 URL
      const targetUrl = url.searchParams.get('url');
      if (!targetUrl) {
        return Response.json(
          { error: '缺少 url 参数' },
          { status: 400 }
        );
      }
      
      // 转发请求
      const response = await fetch(targetUrl, {
        method: request.method,
        headers: request.headers,
        body: request.body
      });
      
      // 创建新的响应，添加 CORS 头
      const newResponse = new Response(response.body, response);
      newResponse.headers.set(
        'Access-Control-Allow-Origin',
        isAllowed ? origin || '*' : 'null'
      );
      
      return newResponse;
      
    } catch (error) {
      return Response.json(
        { 
          error: '代理请求失败',
          message: error instanceof Error ? error.message : 'Unknown'
        },
        { status: 500 }
      );
    }
  }
} satisfies ExportedHandler<Env>;
```

## 部署和测试

### 使用 Wrangler CLI

```bash
# 安装 Wrangler
npm install -g wrangler

# 登录
wrangler login

# 本地开发
wrangler dev

# 部署
wrangler deploy
```

### 测试 Worker

```javascript
// 在 React 应用中测试
const testWorker = async () => {
  try {
    const response = await fetch('https://your-worker.workers.dev/api/status');
    const data = await response.json();
    console.log('Worker 响应:', data);
  } catch (error) {
    console.error('请求失败:', error);
  }
};
```

## 最佳实践

1. 使用 TypeScript：对于生产环境，强烈推荐使用 TypeScript
2. 环境变量：敏感信息使用环境变量而非硬编码
3. 错误处理：始终包含 try-catch 和适当的错误响应
4. CORS 配置：正确设置 CORS 头以支持跨域请求
5. 日志记录：使用 console.log 在 Cloudflare Dashboard 查看日志
6. 限流：实现速率限制防止滥用
7. 缓存：利用 Cache API 提升性能

## 总结

Cloudflare Workers 是一个强大的边缘计算平台，适合：
- API 代理和路由
- 静态资源优化
- A/B 测试
- 认证和鉴权
- 实时数据处理

选择 JavaScript 还是 TypeScript 取决于项目规模和团队偏好，但对于长期维护的项目，TypeScript 是更好的选择。

## 相关资源

- [Cloudflare Workers 官方文档](https://developers.cloudflare.com/workers/)
- [Wrangler CLI 文档](https://developers.cloudflare.com/workers/wrangler/)
- [Workers 示例库](https://developers.cloudflare.com/workers/examples/)
